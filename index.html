<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plataforma Knight</title>
    <!-- Carregamento do Tailwind CSS para utilitários de estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* --- CSS: Variáveis e Estilização Base --- */
      :root {
        --color-dark-bg: #1a1a2e; /* Fundo escuro */
        --color-text-main: #c6d8d8;
        --color-glow: #e0f0f0;
        --color-hover: #ffffff;
        --font-game-title: serif;
        --font-game-menu: "Inter", sans-serif;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family: var(--font-game-menu);
        min-height: 100vh; /* ALTERADO: Garante que o body ocupe a altura total da tela para centralizar corretamente */
        background-color: var(--color-dark-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--color-text-main);
      }

      /* Contêiner de tela para sobrepor e transicionar */
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 1;
        transition: opacity 0.5s ease-in-out;
        pointer-events: auto;
        z-index: 10;
      }

      .screen.hidden {
        opacity: 0;
        pointer-events: none;
        z-index: -1; /* Manda para trás quando escondido */
      }

      /* --- Estilos do Menu Principal/Pausa --- */
      #menu-screen {
        background-image: radial-gradient(
          circle at center,
          #0a1420 0%,
          var(--color-dark-bg) 100%
        );
      }

      /* Container de Pausa: Usa o mesmo estilo, mas é gerado dinamicamente sobre o canvas */
      .menu-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 3rem;
        max-width: 90%;
        text-align: center;
        border: 1px solid rgba(198, 216, 216, 0.1);
        border-radius: 12px;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5),
          0 0 10px rgba(198, 216, 216, 0.05);
      }

      .game-title {
        font-family: var(--font-game-title);
        font-size: clamp(3rem, 10vw, 6rem);
        font-weight: 700;
        margin-bottom: 2rem;
        color: var(--color-glow);
        letter-spacing: 0.5rem;
        text-shadow: 0 0 15px rgba(224, 240, 240, 0.8),
          0 0 5px rgba(224, 240, 240, 0.5);
        text-transform: uppercase;
      }

      .menu-options {
        list-style: none;
        padding: 0;
        margin-top: 1rem;
        width: 100%;
        max-width: 300px;
      }

      .menu-options li {
        margin-bottom: 0.75rem;
      }

      .menu-button {
        background: none;
        border: none;
        color: var(--color-text-main);
        font-size: clamp(1.2rem, 3vw, 1.8rem);
        padding: 0.5rem 1.5rem;
        cursor: pointer;
        width: 100%;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.1rem;
        transition: color 0.2s, text-shadow 0.2s, transform 0.1s;
        position: relative;
        outline: none;
      }

      .menu-button:hover,
      .menu-button:focus {
        color: var(--color-hover);
        text-shadow: 0 0 8px var(--color-glow);
        transform: scale(1.05);
      }

      .menu-button:hover::before,
      .menu-button:focus::before {
        content: ">";
        position: absolute;
        left: 0;
        color: var(--color-glow);
        text-shadow: 0 0 5px var(--color-glow);
        animation: pulse 1.5s infinite alternate;
      }

      @keyframes pulse {
        from {
          opacity: 0.5;
        }
        to {
          opacity: 1;
        }
      }

      /* --- Estilos da Tela do Jogo --- */

      #game-screen {
        background-color: transparent;
        flex-direction: column;
        position: relative;
        z-index: 5;
      }

      #game-canvas {
        display: block;
        /* Dimensões fixas definidas no JS (960x540) */
        width: 960px;
        height: 540px;

        background-color: #000;
        border: 4px solid #4a4e69;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      /* Painel de Informações sobre o Canvas */
      .info-panel {
        position: absolute;
        top: 0;
        left: 0;
        padding: 1rem;
        background-color: rgba(0, 0, 0, 0.7);
        color: #fff;
        font-size: 0.9rem;
        border-radius: 0 0 8px 0;
        z-index: 100;
        width: 350px; /* Aumentado para caber as informações */
      }

      /* Responsividade para telas menores: ajuste o painel de info para o centro-superior */
      @media (max-width: 1000px) {
        #game-canvas {
          width: 90vw;
          height: calc(90vw * 540 / 960);
          max-width: 960px;
          max-height: 540px;
        }
        #game-screen {
          flex-direction: column;
        }
        .info-panel {
          position: relative;
          margin-bottom: 10px;
          border-radius: 8px;
          width: 90vw;
          max-width: 960px;
        }
      }

      /* Estilo da Tela de Pausa no Canvas (overlay) */
      .pause-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 960px; /* Dimensão fixa do Canvas */
        height: 540px; /* Dimensão fixa do Canvas */
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        pointer-events: auto;
      }

      @media (max-width: 1000px) {
        .pause-overlay {
          width: 90vw;
          height: calc(90vw * 540 / 960);
        }
      }
    </style>
  </head>
  <body>
    <!-- INÍCIO DA MÚSICA DE FUNDO -->
    <!-- Esta tag <audio> é responsável por carregar e tocar a música. -->
    <!-- 'autoplay' tenta iniciar a música automaticamente (pode ser bloqueado pelo navegador) -->
    <!-- 'loop' garante que a música recomece após o término -->
    <!-- 'controls' mostra os controles de play/pause/volume para o usuário -->
    <!-- IMPORTANTE: Substitua 'musica.mp3' pelo nome do seu arquivo MP3. -->
    <audio id="background-music" autoplay loop controls class="hidden">
      <source src="music/Hollow Knight OST - Dirtmouth.mp3" type="audio/mpeg" />
      Seu navegador não suporta o elemento de áudio.
    </audio>
    <!-- FIM DA MÚSICA DE FUNDO -->
    <!-- 1. TELA DO MENU PRINCIPAL -->
    <div id="menu-screen" class="screen">
      <div class="menu-container">
        <h1 class="game-title">HOLLOW KNIGHT</h1>
        <ul id="main-menu-options" class="menu-options">
          <!-- Buttons are inserted by JS to reuse logic -->
        </ul>
      </div>
    </div>

    <!-- 2. TELA DO JOGO -->
    <div id="game-screen" class="screen hidden">
      <canvas id="game-canvas"></canvas>

      <!-- Container para o Menu de Pausa (será preenchido via JS) -->
      <div id="pause-container" class="pause-overlay hidden">
        <div id="pause-menu" class="menu-container">
          <h1 class="game-title text-5xl">JOGO PAUSADO</h1>
          <ul id="pause-menu-options" class="menu-options">
            <!-- Buttons are inserted by JS to reuse logic -->
          </ul>
        </div>
      </div>

      <div class="info-panel">
        <p>Controles:</p>
        <p class="font-bold">
          A D: Mover | W: Pular | <span class="text-yellow-400">Q: DASH</span>
        </p>
        <p class="font-bold">
          S: Defender | Espaço: Atacar Normal |
          <span class="text-red-400">ESC: Pausar</span>
        </p>
        <p class="mt-2 text-sm text-yellow-300">
          HP (Cura 50%): Surge a cada 30s
        </p>
        <p class="text-sm text-red-400 font-bold mt-1">
          Nível Atual: <span id="level-display">1 (Floresta Antiga)</span>
        </p>
        <p class="text-sm text-red-400 font-bold">
          Dificuldade: A velocidade dos inimigos aumenta com a pontuação!
        </p>
        <p class="text-sm text-blue-300">
          IA Inimiga: Eles pularão para tentar alcançá-lo!
        </p>
      </div>
    </div>

    <!-- Assets Preload (Imagens com placeholders de falha) -->
    <div id="assets-preload" style="display: none">
      <img
        id="fundo-img"
        src="assets/fundo.png"
        onerror="this.src='https://placehold.co/960x540/4a4e69/ffffff?text=FUNDO_FALHA'"
        alt="Imagem de Fundo"
      />
      <img
        id="chao-img"
        src="assets/chao.png"
        onerror="this.src='https://placehold.co/500x100/38b000/000000?text=CHAO_FALHA'"
        alt="Imagem do Chão"
      />
      <img
        id="parado-img"
        src="assets/personagem_parado.png"
        onerror="this.src='https://placehold.co/80x80/2f3e46/ffffff?text=PARADO_FALHA'"
        alt="Personagem Parado"
      />
      <img
        id="pulando-img"
        src="assets/personagem_pulando.png"
        onerror="this.src='https://placehold.co/80x80/0077b6/ffffff?text=PULO_FALHA'"
        alt="Personagem Pulando"
      />
      <img
        id="correndo1-img"
        src="assets/personagem_correndo_1.png"
        onerror="this.src='https://placehold.co/80x80/ef476f/ffffff?text=RUN1_FALHA'"
        alt="Corrida Frame 1"
      />
      <img
        id="correndo2-img"
        src="assets/personagem_correndo_2.png"
        onerror="this.src='https://placehold.co/80x80/ffd166/000000?text=RUN2_FALHA'"
        alt="Corrida Frame 2"
      />
      <img
        id="correndo3-img"
        src="assets/personagem_correndo_3.png"
        onerror="this.src='https://placehold.co/80x80/06d6a0/ffffff?text=RUN3_FALHA'"
        alt="Corrida Frame 3 (Arma p/ trás)"
      />
      <img
        id="correndo4-img"
        src="assets/personagem_correndo_4.png"
        onerror="this.src='https://placehold.co/80x80/118ab2/ffffff?text=RUN4_FALHA'"
        alt="Corrida Frame 4"
      />
      <!-- ANIMAÇÕES DO JOGADOR -->
      <img
        id="atacando1-img"
        src="assets/personagem_atacando1.png"
        onerror="this.src='https://placehold.co/80x80/ff595e/ffffff?text=ATK1_FALHA'"
        alt="Ataque Frame 1"
      />
      <img
        id="atacando2-img"
        src="assets/personagem_atacando2.png"
        onerror="this.src='https://placehold.co/80x80/ff924c/ffffff?text=ATK2_FALHA'"
        alt="Ataque Frame 2"
      />
      <img
        id="atacando3-img"
        src="assets/personagem_atacando3.png"
        onerror="this.src='https://placehold.co/80x80/ffce54/000000?text=ATK3_FALHA'"
        alt="Ataque Frame 3"
      />
      <img
        id="defendendo1-img"
        src="assets/personagem_defendendo1.png"
        onerror="this.src='https://placehold.co/80x80/4caf50/ffffff?text=DEF1_FALHA'"
        alt="Defesa Frame 1"
      />
      <img
        id="defendendo2-img"
        src="assets/personagem_defendendo2.png"
        onerror="this.src='https://placehold.co/80x80/81c784/ffffff?text=DEF2_FALHA'"
        alt="Defesa Frame 2"
      />
      <img
        id="defendendo3-img"
        src="assets/personagem_defendendo3.png"
        onerror="this.src='https://placehold.co/80x80/a5d6a7/ffffff?text=DEF3_FALHA'"
        alt="Defesa Frame 3"
      />
      <!-- IMAGENS DO INIMIGO -->
      <img
        id="inimigo-img"
        src="img/inimigo_correndo_1.png"
        onerror="this.src='https://placehold.co/80x80/cc0000/ffffff?text=ENEMY_PARADO'"
        alt="Inimigo Parado/Corrida"
      />
      <!-- NOVOS FRAMES DE CORRIDA DO INIMIGO -->
      <img
        id="inimigo_correndo1-img"
        src="img/inimigo_correndo_1.png"
        onerror="this.src='https://placehold.co/80x80/cc0000/ffffff?text=ENEMY_RUN1'"
        alt="Inimigo Corrida Frame 1"
      />
      <img
        id="inimigo_correndo2-img"
        src="img/inimigo_correndo_2.png"
        onerror="this.src='https://placehold.co/80x80/cc0000/ffffff?text=ENEMY_RUN2'"
        alt="Inimigo Corrida Frame 2"
      />
      <img
        id="inimigo_correndo3-img"
        src="img/inimigo_correndo_3.png"
        onerror="this.src='https://placehold.co/80x80/cc0000/ffffff?text=ENEMY_RUN3'"
        alt="Inimigo Corrida Frame 3"
      />
      <img
        id="inimigo_correndo4-img"
        src="img/inimigo_correndo_4.png"
        onerror="this.src='https://placehold.co/80x80/cc0000/ffffff?text=ENEMY_RUN4'"
        alt="Inimigo Corrida Frame 4"
      />

      <img
        id="inimigo_atacando1-img"
        src="img/inimigo_atacando1.png"
        onerror="this.src='https://placehold.co/80x80/b70000/ffffff?text=EATK1_FALHA'"
        alt="Inimigo Ataque Frame 1"
      />
      <img
        id="inimigo_atacando2-img"
        src="img/inimigo_atacando2.png"
        onerror="this.src='https://placehold.co/80x80/d90000/ffffff?text=EATK2_FALHA'"
        alt="Inimigo Ataque Frame 2"
      />
      <img
        id="inimigo_atacando3-img"
        src="img/inimigo_atacando3.png"
        onerror="this.src='https://placehold.co/80x80/ff0000/ffffff?text=EATK3_FALHA'"
        alt="Inimigo Ataque Frame 3"
      />
      <!-- NOVO: IMAGEM PARA O HP PICKUP -->
      <img
        id="hp_pickup-img"
        src="assets/hp.png"
        onerror="this.src='https://placehold.co/40x40/00b894/ffffff?text=HP'"
        alt="Health Pickup"
      />

      <!-- NOVAS IMAGENS DO INIMIGO NÍVEL 2 (CIANO) -->
      <img
        id="inimigo_nivel2_correndo1-img"
        src="img/inimigo_nivel2_correndo1.png"
        onerror="this.src='https://placehold.co/80x80/00ccff/000000?text=E2_RUN1'"
        alt="Inimigo Nível 2 Corrida Frame 1"
      />
      <img
        id="inimigo_nivel2_correndo2-img"
        src="img/inimigo_nivel2_correndo2.png"
        onerror="this.src='https://placehold.co/80x80/00ccff/000000?text=E2_RUN2'"
        alt="Inimigo Nível 2 Corrida Frame 2"
      />
      <img
        id="inimigo_nivel2_correndo3-img"
        src="img/inimigo_nivel2_correndo3.png"
        onerror="this.src='https://placehold.co/80x80/00ccff/000000?text=E2_RUN3'"
        alt="Inimigo Nível 2 Corrida Frame 3"
      />
      <img
        id="inimigo_nivel2_correndo4-img"
        src="img/inimigo_nivel2_correndo4.png"
        onerror="this.src='https://placehold.co/80x80/00ccff/000000?text=E2_RUN4'"
        alt="Inimigo Nível 2 Corrida Frame 4"
      />
      <img
        id="inimigo_nivel2_atacando1-img"
        src="img/inimigo_nivel2_atacando1.png"
        onerror="this.src='https://placehold.co/80x80/0099ff/000000?text=E2_ATK1_FALHA'"
        alt="Inimigo Nível 2 Ataque Frame 1"
      />
      <img
        id="inimigo_nivel2_atacando2-img"
        src="img/inimigo_nivel2_atacando2.png"
        onerror="this.src='https://placehold.co/80x80/0066ff/000000?text=E2_ATK2_FALHA'"
        alt="Inimigo Nível 2 Ataque Frame 2"
      />
      <img
        id="inimigo_nivel2_atacando3-img"
        src="img/inimigo_nivel2_atacando3.png"
        onerror="this.src='https://placehold.co/80x80/0033ff/000000?text=E2_ATK3_FALHA'"
        alt="Inimigo Nível 2 Ataque Frame 3"
      />

      <!-- IMAGEM BASE HP PICKUP -->
      <img
        id="hp_pickup-img"
        src="assets/health_pickup.png"
        onerror="this.src='https://placehold.co/40x40/00b894/ffffff?text=HP'"
        alt="Health Pickup"
      />
      <!-- HP PICKUP ANIMATION FRAMES (3 Frames) -->
      <img
        id="hp_pickup_frame1-img"
        src="assets/health_pickup_1.png"
        onerror="this.src='https://placehold.co/40x40/00b894/ffffff?text=HP1'"
        alt="Health Pickup Frame 1"
      />
      <img
        id="hp_pickup_frame2-img"
        src="assets/health_pickup_2.png"
        onerror="this.src='https://placehold.co/40x40/00b894/ffffff?text=HP2'"
        alt="Health Pickup Frame 2"
      />
      <img
        id="hp_pickup_frame3-img"
        src="assets/health_pickup_3.png"
        onerror="this.src='https://placehold.co/40x40/00b894/ffffff?text=HP3'"
        alt="Health Pickup Frame 3"
      />
    </div>

    <script>
      // --- 1. Inicialização e Configuração de Dimensão Fixa ---
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const menuScreen = document.getElementById("menu-screen");
      const gameScreen = document.getElementById("game-screen");
      const mainMenuOptions = document.getElementById("main-menu-options");
      const pauseContainer = document.getElementById("pause-container");
      const pauseMenuOptions = document.getElementById("pause-menu-options");
      const levelDisplay = document.getElementById("level-display");

      let animationFrameId = null;
      let lastMousePos = { x: 0, y: 0 };

      // Dimensões fixas definidas no CSS
      const GAME_WIDTH = 960;
      const GAME_HEIGHT = 540;

      // Define as dimensões internas do Canvas
      canvas.width = GAME_WIDTH;
      canvas.height = GAME_HEIGHT;

      // --- 2. Variáveis de Jogo e Dimensão ---
      const CHAO_ALTURA_IMAGEM = 100;
      const PERSONAGEM_TAMANHO = 80;

      const ALTURA_COLISAO_JOGAVEL = 70;

      const CHAO_Y_DESENHO = GAME_HEIGHT - CHAO_ALTURA_IMAGEM;
      const CHAO_Y_COLISAO = CHAO_Y_DESENHO + ALTURA_COLISAO_JOGAVEL;

      let isGameOver = false;

      // Gerenciamento de Estado
      const GAME_STATE = {
        MENU: "MENU",
        PLAYING: "PLAYING",
        PAUSED: "PAUSED",
        GAME_OVER: "GAME_OVER",
      };
      let currentGameState = GAME_STATE.MENU;

      // NOVO: Variável de Controle de Nível
      let currentLevel = 1;

      // NOVO: Dados de Configuração por Nível
      const LEVEL_DATA = {
        1: {
          name: "Floresta Antiga",
          fundoCor: "#1a1a2e",
          chaoCor: "#2e3a59",
          enemyBaseSpeed: 2.0,
          enemyHealth: 50,
          scoreRequirement: 2000,
        },
        2: {
          name: "Caverna de Cristal",

          enemyBaseSpeed: 3.5, // Mais rápido
          enemyHealth: 80, // Mais vida
          enemyScale: 1.1, // 10% maior
          scoreRequirement: Infinity, // Fim do jogo (por enquanto)
        },
      };

      // Constantes de Dificuldade (Usadas em conjunto com LEVEL_DATA)
      const MAX_VELOCIDADE_INIMIGO = 6.0;
      const SCORE_VELOCIDADE_FATOR = 0.002;
      const MIN_SPAWN_INTERVALO = 90;
      const MAX_SPAWN_INTERVALO = 180;
      const SCORE_SPAWN_FATOR = 0.05;

      // --- 3. Carregamento de Imagens (Do DOM) ---
      const IMAGENS = {
        fundo: document.getElementById("fundo-img"),
        chao: document.getElementById("chao-img"),
        parado: document.getElementById("parado-img"),
        pulando: document.getElementById("pulando-img"),
        correndo: [
          document.getElementById("correndo1-img"),
          document.getElementById("correndo2-img"),
          document.getElementById("correndo3-img"),
          document.getElementById("correndo4-img"),
        ],
        atacando: [
          document.getElementById("atacando1-img"),
          document.getElementById("atacando2-img"),
          document.getElementById("atacando3-img"),
        ],
        defendendo: [
          document.getElementById("defendendo1-img"),
          document.getElementById("defendendo2-img"),
          document.getElementById("defendendo3-img"),
        ],
        inimigo: document.getElementById("inimigo-img"),
        inimigoCorrendo: [
          document.getElementById("inimigo_correndo1-img"),
          document.getElementById("inimigo_correndo2-img"),
          document.getElementById("inimigo_correndo3-img"),
          document.getElementById("inimigo_correndo4-img"),
        ],
        inimigoAtacando: [
          document.getElementById("inimigo_atacando1-img"),
          document.getElementById("inimigo_atacando2-img"),
          document.getElementById("inimigo_atacando3-img"),
        ],
        // NOVO: Imagens do Nível 2
        inimigoLevel2Correndo: [
          document.getElementById("inimigo_nivel2_correndo1-img"),
          document.getElementById("inimigo_nivel2_correndo2-img"),
          document.getElementById("inimigo_nivel2_correndo3-img"),
          document.getElementById("inimigo_nivel2_correndo4-img"),
        ],
        inimigoLevel2Atacando: [
          document.getElementById("inimigo_nivel2_atacando1-img"),
          document.getElementById("inimigo_nivel2_atacando2-img"),
          document.getElementById("inimigo_nivel2_atacando3-img"),
        ],
        hp_pickup: document.getElementById("hp_pickup-img"),
        hp_pickup_anim: [
          document.getElementById("hp_pickup_frame1-img"),
          document.getElementById("hp_pickup_frame2-img"),
          document.getElementById("hp_pickup_frame3-img"),
        ],
      };

      // --- 4. Classes de Jogo e Inicialização de Objetos ---

      // 4.1 CLASSE BASE: ObjetoVivo (Player e Inimigos)
      class ObjetoVivo {
        constructor(x, y, tamanho) {
          this.posX = x;
          this.posY = y;
          this.tamanho = tamanho;
          this.vidaMaxima = 100; // BASE HP
          this.vidaAtual = 100; // BASE HP
          this.direcao = 1;
          this.noChao = true;
          this.velY = 0;
        }

        drawBarraVida(ctx, offsetX = 0) {
          const barraWidth = this.tamanho;
          const barraHeight = 8;
          const barraX = this.posX - offsetX;
          const barraY = this.posY - barraHeight - 5;
          const vidaPercentual = Math.max(0, this.vidaAtual / this.vidaMaxima);

          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(barraX, barraY, barraWidth, barraHeight);

          // Cor da barra de vida: verde se > 30%, vermelho se <= 30%
          ctx.fillStyle = vidaPercentual > 0.3 ? "#00ff41" : "#ff0041";
          ctx.fillRect(
            barraX,
            barraY,
            barraWidth * vidaPercentual,
            barraHeight
          );

          ctx.strokeStyle = "#fff";
          ctx.strokeRect(barraX, barraY, barraWidth, barraHeight);
        }
      }

      // 4.2 CLASSE INIMIGO (MODIFICADA COM AI E FÍSICA)
      class Inimigo extends ObjetoVivo {
        constructor(x, y, tamanho, levelData) {
          const finalSize = levelData.enemyScale
            ? tamanho * levelData.enemyScale
            : tamanho;
          super(x, y, finalSize);
          this.levelData = levelData;
          this.velocidade = levelData.enemyBaseSpeed;
          this.vidaAtual = levelData.enemyHealth;
          this.vidaMaxima = levelData.enemyHealth;

          this.isAttacking = false;
          this.attackTimer = 0;
          this.isDead = false;
          // Decide qual set de animação usar
          const attackFrames =
            this.levelData.name === LEVEL_DATA[2].name
              ? IMAGENS.inimigoLevel2Atacando
              : IMAGENS.inimigoAtacando;
          this.attackDuration = attackFrames.length * ANIMACAO_VELOCIDADE;
          this.animacaoFrame = 0;

          this.velX = -this.velocidade;
          this.velY = 0;
          this.gravity = GRAVIDADE;
          this.direcao = -1;
        }

        update(jogador) {
          if (this.isDead) return;

          const LIMITE_CHAO_INIMIGO = CHAO_Y_COLISAO - this.tamanho;

          // 1. Lógica de AI e Movimento
          const playerAbove = jogador.posY < this.posY - 10;
          const distanceX = jogador.posX - this.posX;
          const isClose = Math.abs(distanceX) < GAME_WIDTH / 2;

          if (this.noChao) {
            this.velY = 0;

            if (!this.isAttacking) {
              // AI: Tenta pular se o jogador estiver acima e perto
              if (
                (playerAbove || !jogador.noChao) &&
                isClose &&
                Math.random() < 0.05
              ) {
                this.velY = -15;
                this.noChao = false;
                this.velX = Math.sign(distanceX) * (this.velocidade * 1.5);
                this.direcao = Math.sign(distanceX);
              }
            }
          }

          // Movimento horizontal (seguindo o jogador se não estiver pulando/atacando)
          if (this.noChao && !this.isAttacking) {
            if (isClose) {
              this.velX = Math.sign(distanceX) * this.velocidade;
              this.direcao = Math.sign(distanceX);
            } else {
              this.velX = -this.velocidade;
              this.direcao = -1;
            }
          } else if (this.isAttacking) {
            this.velX = 0;
          }

          // 2. Aplica Física
          this.velY += this.gravity;
          this.posX += this.velX;
          this.posY += this.velY;

          // 3. Colisão com o chão
          if (this.posY >= LIMITE_CHAO_INIMIGO) {
            this.posY = LIMITE_CHAO_INIMIGO;
            this.velY = 0;
            this.noChao = true;
          }

          // 4. Lógica do ataque (timer)
          if (this.isAttacking) {
            this.attackTimer++;
            if (this.attackTimer >= this.attackDuration) {
              this.isAttacking = false;
              this.attackTimer = 0;
            }
          }
        }

        draw(ctx) {
          ctx.save();

          // Seleciona os frames de acordo com o Nível
          const isLevel2 = this.levelData.name === LEVEL_DATA[2].name;
          const runFrames = isLevel2
            ? IMAGENS.inimigoLevel2Correndo
            : IMAGENS.inimigoCorrendo;
          const attackFrames = isLevel2
            ? IMAGENS.inimigoLevel2Atacando
            : IMAGENS.inimigoAtacando;

          let imagem;
          if (this.isAttacking) {
            const frameIndex =
              Math.floor(this.attackTimer / ANIMACAO_VELOCIDADE) %
              attackFrames.length;
            imagem = attackFrames[frameIndex];
          } else {
            // Se estiver no chão e se movendo, usa a animação de corrida
            const frameIndex =
              this.noChao && this.velX !== 0
                ? Math.floor(this.animacaoFrame / ANIMACAO_VELOCIDADE) %
                  runFrames.length
                : 0;

            this.animacaoFrame =
              (this.animacaoFrame + 1) %
              (runFrames.length * ANIMACAO_VELOCIDADE);
            imagem = runFrames[frameIndex];
          }

          const drawX = this.posX;

          let mustFlip = false;

          if (isLevel2) {
            // Nível 2: O sprite base está virado para a ESQUERDA (direcao -1).
            // Precisa virar (flip) APENAS se estiver indo para a DIREITA (direcao 1).
            if (this.direcao === 1) {
              mustFlip = true;
            }
          } else {
            // Nível 1: O sprite base está virado para a DIREITA (direcao 1).
            // Precisa virar (flip) APENAS se estiver indo para a ESQUERDA (direcao -1).
            if (this.direcao === -1) {
              mustFlip = true;
            }
          }

          // Aplica o espelhamento
          if (mustFlip) {
            ctx.translate(drawX + this.tamanho, this.posY);
            ctx.scale(-1, 1);
            ctx.drawImage(imagem, 0, 0, this.tamanho, this.tamanho);
          } else {
            ctx.drawImage(imagem, drawX, this.posY, this.tamanho, this.tamanho);
          }

          this.drawBarraVida(ctx);
          ctx.restore();
        }
      }

      // 4.3 CLASSE HEALTH PICKUP
      class HealthPickup {
        constructor(x, y, size) {
          this.posX = x;
          this.tamanho = size;
          this.isConsumed = false;
          this.floatOffset = 0;
          this.floatSpeed = 0.005;
          this.baseY = y;
          this.posY = y;

          this.isPickingUp = false;
          this.pickupFrame = 0;
          this.pickupDuration =
            IMAGENS.hp_pickup_anim.length * ANIMACAO_VELOCIDADE;
        }

        update() {
          if (this.isPickingUp) {
            this.pickupFrame++;
            // Se a animação de coleta terminou, marca como consumido
            if (this.pickupFrame >= this.pickupDuration) {
              this.isConsumed = true;
            }
            return;
          }

          this.floatOffset = Math.sin(Date.now() * this.floatSpeed) * 5;
          this.posY = this.baseY + this.floatOffset;
        }

        draw(ctx) {
          if (this.isPickingUp) {
            // Desenha o frame da animação de coleta
            const index = Math.floor(this.pickupFrame / ANIMACAO_VELOCIDADE);
            const image = IMAGENS.hp_pickup_anim[index];
            if (image) {
              ctx.drawImage(
                image,
                this.posX,
                this.posY,
                this.tamanho,
                this.tamanho
              );
            }
          } else {
            // Desenha o item normal flutuando
            ctx.drawImage(
              IMAGENS.hp_pickup,
              this.posX,
              this.posY,
              this.tamanho,
              this.tamanho
            );
          }
        }
      }

      // NOVO: 4.4 CLASSE PORTA (Level Transition)
      class Door {
        constructor(x, y, size) {
          this.posX = x;
          this.posY = y;
          this.tamanho = size;
          this.isClosed = true;
        }

        draw(ctx) {
          // Simulação de uma porta (cor e forma)
          ctx.fillStyle = this.isClosed ? "#8b4513" : "#4CAF50"; // Marrom (fechada) ou Verde (aberta)
          ctx.fillRect(this.posX, this.posY, this.tamanho, this.tamanho * 2);

          // Detalhe de luz/abertura
          ctx.fillStyle = this.isClosed ? "#542f0b" : "#aaffaa";
          ctx.fillRect(
            this.posX + 5,
            this.posY + 5,
            this.tamanho - 10,
            this.tamanho * 2 - 10
          );

          // Se estiver aberta, mostra um brilho para o próximo mapa
          if (!this.isClosed) {
            ctx.fillStyle = "rgba(170, 255, 170, 0.5)";
            ctx.fillRect(
              this.posX + 15,
              this.posY + 15,
              this.tamanho - 30,
              this.tamanho * 2 - 30
            );
          }

          ctx.strokeStyle = "#000";
          ctx.lineWidth = 3;
          ctx.strokeRect(this.posX, this.posY, this.tamanho, this.tamanho * 2);

          ctx.fillStyle = "#fff";
          ctx.font = "bold 16px Inter";
          ctx.textAlign = "center";
          ctx.fillText(
            this.isClosed
              ? `SCORE ${LEVEL_DATA[currentLevel].scoreRequirement}`
              : "PRÓXIMO NÍVEL",
            this.posX + this.tamanho / 2,
            this.posY - 10
          );
        }

        checkCollision(player) {
          return (
            player.posX < this.posX + this.tamanho &&
            player.posX + player.tamanho > this.posX &&
            player.posY < this.posY + this.tamanho * 2 &&
            player.posY + player.tamanho > this.posY
          );
        }
      }

      // 4.5 INICIALIZAÇÃO DE OBJETOS E VARIÁVEIS
      const TAMANHO_JOGADOR = PERSONAGEM_TAMANHO;
      const LIMITE_CHAO_JOGADOR = CHAO_Y_COLISAO - TAMANHO_JOGADOR;

      const jogador = new ObjetoVivo(50, LIMITE_CHAO_JOGADOR, TAMANHO_JOGADOR);
      jogador.score = 0;
      jogador.isAttacking = false;
      jogador.isDefending = false;
      jogador.isDashing = false;
      jogador.attackTimer = 0;
      jogador.defendTimer = 0;
      jogador.dashCooldown = 0;
      jogador.dashTimer = 0;

      const DASH_DURATION = 10; // Frames
      const DASH_COOLDOWN_TIME = 90; // Frames (1.5 segundos a 60 FPS)
      const DASH_VELOCITY = 18; // Quão rápido é o Dash

      const ANIMACAO_VELOCIDADE = 5;
      const PLAYER_ATTACK_DURATION =
        IMAGENS.atacando.length * ANIMACAO_VELOCIDADE;
      const PLAYER_DEFEND_DURATION =
        IMAGENS.defendendo.length * ANIMACAO_VELOCIDADE;

      const inimigos = [];
      let velX = 0;
      let velY = 0;
      let animacaoFrame = 0;
      let cameraOffset = 0;
      let spawnTimer = 0;

      const healthPickups = [];
      let healthSpawnTimer = 0;
      const HEALTH_SPAWN_INTERVAL = 1800;
      const HEALTH_PICKUP_SIZE = 40;
      const HEALTH_PICKUP_Y = CHAO_Y_COLISAO - HEALTH_PICKUP_SIZE;

      // NOVO: Variáveis da Porta
      let levelDoor = null;
      const DOOR_SIZE = 50;
      const DOOR_Y = CHAO_Y_COLISAO - DOOR_SIZE * 2;

      const GRAVIDADE = 0.8;
      const VELOCIDADE_HORIZONTAL = 5;
      const FORCA_PULO = 18;
      const CAMERA_LIMITE_ESQ = GAME_WIDTH / 4;
      const CAMERA_LIMITE_DIR = GAME_WIDTH * 0.75;

      // Estado das Teclas Pressionadas
      const teclas = {};
      document.addEventListener("keydown", (e) => {
        const key = e.key.toLowerCase();
        if (key === " " || key === "w" || key === "q") e.preventDefault();
        teclas[key] = true;

        // Pausar o Jogo
        if (e.key === "Escape") {
          if (currentGameState === GAME_STATE.PLAYING) {
            pauseGame();
          } else if (currentGameState === GAME_STATE.PAUSED) {
            unpauseGame();
          }
        }
      });
      document.addEventListener("keyup", (e) => {
        teclas[e.key.toLowerCase()] = false;
      });

      // --- Funções de Transição de Tela e Reset ---

      function updateLevelDisplay() {
        const data = LEVEL_DATA[currentLevel];
        levelDisplay.textContent = `${currentLevel} (${data.name})`;
      }

      function updatePauseMenuVisibility() {
        if (currentGameState === GAME_STATE.PAUSED) {
          pauseContainer.classList.remove("hidden");
          // Foca o primeiro botão para navegação com teclado
          const firstButton = pauseMenuOptions.querySelector(".menu-button");
          if (firstButton) firstButton.focus();
        } else {
          pauseContainer.classList.add("hidden");
        }
      }

      function pauseGame() {
        if (currentGameState === GAME_STATE.PLAYING) {
          currentGameState = GAME_STATE.PAUSED;
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          updatePauseMenuVisibility();
        }
      }

      function unpauseGame() {
        if (currentGameState === GAME_STATE.PAUSED) {
          currentGameState = GAME_STATE.PLAYING;
          updatePauseMenuVisibility();
          gameLoop(); // Retoma o loop
        }
      }

      function showScreen(screenToShow) {
        const screens = [menuScreen, gameScreen];
        screens.forEach((screen) => {
          if (screen === screenToShow) {
            screen.classList.remove("hidden");
          } else {
            screen.classList.add("hidden");
          }
        });
      }

      function focusFirstMenuButton(ulElement) {
        const buttons = ulElement.querySelectorAll(".menu-button");
        if (buttons.length > 0) {
          buttons[0].focus();
        }
      }

      function backToMenu() {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        isGameOver = false;
        currentGameState = GAME_STATE.MENU;
        showScreen(menuScreen);
        updatePauseMenuVisibility();
        focusFirstMenuButton(mainMenuOptions);

        currentLevel = 1; // Garante reset do nível para o menu
        jogador.vidaMaxima = 100; // Garante que a vida máxima base seja redefinida
        levelDoor = null;
      }

      // NOVO: Função para transicionar para o próximo nível
      function goToNextLevel(newLevel) {
        const nextLevelData = LEVEL_DATA[newLevel];

        if (!nextLevelData) {
          console.log("Parabéns! Fim da Demo!");
          // Aqui você pode forçar um Game Over ou uma tela de vitória
          jogador.score += 5000;
          currentGameState = GAME_STATE.GAME_OVER;
          return;
        }

        currentLevel = newLevel;

        // LÓGICA DE AUMENTO DE VIDA NO NÍVEL 2
        if (newLevel === 2) {
          jogador.vidaMaxima = 150; // NOVO: Aumenta a vida máxima no Nível 2
        } else {
          // Se estiver voltando para um nível anterior, ou nível 1, reseta para base
          jogador.vidaMaxima = 100;
        }
        // Garante que a vida atual não exceda o novo máximo
        jogador.vidaAtual = Math.min(jogador.vidaAtual, jogador.vidaMaxima);

        // Resetar estado do jogador (mantém vida e score)
        jogador.posX = 50;
        jogador.posY = LIMITE_CHAO_JOGADOR;
        jogador.velY = 0;
        jogador.noChao = true;

        // Resetar o mundo
        inimigos.length = 0;
        healthPickups.length = 0;
        levelDoor = null;

        // Resetar timers e câmera
        spawnTimer = 0;
        healthSpawnTimer = 0;
        cameraOffset = 0;

        updateLevelDisplay();
        unpauseGame();
      }

      // Função para reiniciar o jogo (reseta o estado e chama startGame)
      function restartGame() {
        // Resetar estado do jogador
        jogador.vidaMaxima = 100; // NOVO: Garante que a vida máxima comece em 100
        jogador.vidaAtual = jogador.vidaMaxima;
        jogador.score = 0;
        jogador.posX = 50;
        jogador.isAttacking = false;
        jogador.isDefending = false;
        jogador.isDashing = false;
        jogador.attackTimer = 0;
        jogador.defendTimer = 0;
        jogador.dashCooldown = 0;
        jogador.dashTimer = 0;

        // Resetar o mundo
        inimigos.length = 0;
        healthPickups.length = 0;
        levelDoor = null;

        currentLevel = 1; // Sempre começa no Nível 1
        spawnTimer = 0;
        healthSpawnTimer = 0;
        cameraOffset = 0;

        // Resetar variáveis de Game Over
        isGameOver = false;
        currentGameState = GAME_STATE.PLAYING;

        // Iniciar o jogo
        startGame();
      }

      // --- Funções para desenhar as Telas Finais ---

      function drawMenuButtonOnCanvas(ctx, text, x, y, w, h, isHovered) {
        const BG_COLOR = isHovered
          ? "rgba(74, 85, 104, 0.8)"
          : "rgba(58, 58, 58, 0.9)";
        const GLOW_COLOR = "#a0b9c5";

        ctx.strokeStyle = isHovered ? GLOW_COLOR : "#c6d8d8";
        ctx.lineWidth = 3;
        ctx.fillStyle = BG_COLOR;

        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);

        ctx.fillStyle = isHovered ? "#fff" : "#c6d8d8";
        if (isHovered) {
          ctx.shadowColor = GLOW_COLOR;
          ctx.shadowBlur = 8;
        }

        ctx.font = "bold 24px Inter, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(text, x + w / 2, y + h / 2 + 8);

        ctx.shadowBlur = 0;
      }

      canvas.addEventListener("mousemove", (e) => {
        if (currentGameState !== GAME_STATE.GAME_OVER) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        lastMousePos.x = (e.clientX - rect.left) * scaleX;
        lastMousePos.y = (e.clientY - rect.top) * scaleY;
      });

      // Listener de clique para o Game Over (no Canvas)
      canvas.addEventListener("click", (e) => {
        if (currentGameState !== GAME_STATE.GAME_OVER) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        const btnWidth = 250;
        const btnHeight = 60;
        const btnX = GAME_WIDTH / 2 - btnWidth / 2;
        const btnY = GAME_HEIGHT / 2 + 80;

        // Checa o clique em VOLTAR AO MENU
        if (
          mouseX >= btnX &&
          mouseX <= btnX + btnWidth &&
          mouseY >= btnY &&
          mouseY <= btnY + btnHeight
        ) {
          backToMenu();
        }
      });

      // --- Função para desenhar a tela de FIM DE JOGO ---
      function drawGameOverScreen() {
        isGameOver = true;

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.font = "bold 72px serif";
        ctx.textAlign = "center";

        ctx.fillStyle = "#e0f0f0";
        ctx.shadowColor = "#a0b9c5";
        ctx.shadowBlur = 10;
        ctx.fillText("FIM DE JOGO", GAME_WIDTH / 2, GAME_HEIGHT / 2 - 80);
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#fff";
        ctx.font = "24px Inter, sans-serif";
        ctx.fillText(
          "Sua aventura termina aqui.",
          GAME_WIDTH / 2,
          GAME_HEIGHT / 2 - 30
        );

        ctx.fillStyle = "#fff";
        ctx.font = "bold 32px Inter, sans-serif";
        ctx.fillText(
          `Pontuação Final: ${jogador.score}`,
          GAME_WIDTH / 2,
          GAME_HEIGHT / 2 + 20
        );

        const btnWidth = 250;
        const btnHeight = 60;
        const btnX = GAME_WIDTH / 2 - btnWidth / 2;
        const btnY = GAME_HEIGHT / 2 + 80;

        const mouseX = lastMousePos.x;
        const mouseY = lastMousePos.y;

        const isHovered =
          mouseX >= btnX &&
          mouseX <= btnX + btnWidth &&
          mouseY >= btnY &&
          mouseY <= btnY + btnHeight;

        drawMenuButtonOnCanvas(
          ctx,
          "VOLTAR AO MENU",
          btnX,
          btnY,
          btnWidth,
          btnHeight,
          isHovered
        );

        animationFrameId = requestAnimationFrame(drawGameOverScreen);
      }

      // --- 7. FUNÇÃO DE DESENHO (DRAW) ---
      function draw() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // --- Aplicar Offset da Câmera ---
        ctx.save();
        ctx.translate(-cameraOffset, 0);

        const currentLevelData = LEVEL_DATA[currentLevel];

        // 1. Fundo do Canvas (fallback color)
        ctx.fillStyle = currentLevelData.fundoCor;
        ctx.fillRect(cameraOffset, 0, GAME_WIDTH, GAME_HEIGHT); // Preenche a área de visualização

        // 2. Desenha o Fundo (Repetição infinita)
        const fundoImg = IMAGENS.fundo;
        const fundoW =
          fundoImg.naturalWidth > 0 ? fundoImg.naturalWidth : GAME_WIDTH;

        const parallaxFactor = 1.0;
        const parallaxOffset = cameraOffset * parallaxFactor;
        const tileIndexStart = Math.floor(parallaxOffset / fundoW);

        for (
          let i = tileIndexStart - 1;
          i <= tileIndexStart + GAME_WIDTH / fundoW + 1;
          i++
        ) {
          const x = i * fundoW;
          ctx.drawImage(fundoImg, x, 0, fundoW, GAME_HEIGHT);
        }

        // 3. Desenha o Chão (Repetição infinita)
        const imgChao = IMAGENS.chao;
        const tileWidth = imgChao.naturalWidth > 0 ? imgChao.naturalWidth : 500;

        ctx.save();
        // Simulação de mudança de textura no Nível 2 através de um overlay de cor
        if (currentLevel === 2) {
          ctx.fillStyle = currentLevelData.chaoCor;
          ctx.fillRect(
            cameraOffset,
            CHAO_Y_DESENHO,
            GAME_WIDTH,
            CHAO_ALTURA_IMAGEM
          );
          ctx.globalAlpha = 0.6;
        }

        const chaoIndexStart = Math.floor(cameraOffset / tileWidth);
        for (
          let i = chaoIndexStart - 1;
          i <= chaoIndexStart + GAME_WIDTH / tileWidth + 1;
          i++
        ) {
          const x = i * tileWidth;
          ctx.drawImage(
            imgChao,
            x,
            CHAO_Y_DESENHO,
            tileWidth,
            CHAO_ALTURA_IMAGEM
          );
        }
        ctx.restore(); // Restaura o globalAlpha e a cor.

        // 4. Desenha Health Pickups
        healthPickups.forEach((hp) => {
          hp.draw(ctx);
        });

        // NOVO: 5. Desenha a Porta
        if (levelDoor) {
          levelDoor.draw(ctx);
        }

        // 6. Desenha o Personagem
        let imagemAtual;
        let correndo =
          velX !== 0 &&
          jogador.noChao &&
          !jogador.isAttacking &&
          !jogador.isDefending &&
          !jogador.isDashing;

        // Prioridade de estado: Dash > Ataque > Defesa > Pulo > Corrida > Parado
        if (jogador.isDashing) {
          imagemAtual = IMAGENS.pulando;
        } else if (jogador.isAttacking) {
          const frameIndex =
            Math.floor(jogador.attackTimer / ANIMACAO_VELOCIDADE) %
            IMAGENS.atacando.length;
          imagemAtual = IMAGENS.atacando[frameIndex];
        } else if (jogador.isDefending) {
          const frameIndex =
            Math.floor(jogador.defendTimer / ANIMACAO_VELOCIDADE) %
            IMAGENS.defendendo.length;
          imagemAtual = IMAGENS.defendendo[frameIndex];
        } else if (!jogador.noChao) {
          imagemAtual = IMAGENS.pulando;
        } else if (correndo) {
          animacaoFrame =
            (animacaoFrame + 1) %
            (IMAGENS.correndo.length * ANIMACAO_VELOCIDADE);
          const frameIndex = Math.floor(animacaoFrame / ANIMACAO_VELOCIDADE);
          imagemAtual = IMAGENS.correndo[frameIndex];
        } else {
          imagemAtual = IMAGENS.parado;
        }

        ctx.globalAlpha = 1.0; // Restaura a opacidade

        // Desenho e Espelhamento do Jogador
        ctx.save();
        if (jogador.direcao === -1) {
          ctx.translate(jogador.posX + jogador.tamanho, jogador.posY);
          ctx.scale(-1, 1);
          ctx.drawImage(imagemAtual, 0, 0, jogador.tamanho, jogador.tamanho);
        } else {
          ctx.drawImage(
            imagemAtual,
            jogador.posX,
            jogador.posY,
            jogador.tamanho,
            jogador.tamanho
          );
        }
        ctx.restore();
        jogador.drawBarraVida(ctx);

        // 7. Desenha Inimigos
        inimigos.forEach((inimigo) => {
          inimigo.draw(ctx);
        });

        // Restaura o canvas do offset da câmera (HUD é fixo)
        ctx.restore();

        // 8. Desenho da HUD (Fixa na tela)
        drawHUD();
      }

      // Desenha a HUD (Barra de Vida, Pontuação e Cooldowns)
      function drawHUD() {
        const hudX = 10;
        const hudY = 10;
        const hudWidth = 200;
        const hudHeight = 30;

        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(hudX, hudY, hudWidth, hudHeight); // Fundo da vida

        const vidaPercentual = jogador.vidaAtual / jogador.vidaMaxima;
        ctx.fillStyle = vidaPercentual > 0.3 ? "#00ff41" : "#ff0041";
        ctx.fillRect(
          hudX + 5,
          hudY + 5,
          (hudWidth - 10) * vidaPercentual,
          hudHeight - 10
        );

        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(hudX, hudY, hudWidth, hudHeight);

        // Texto da Vida
        ctx.fillStyle = "#fff";
        ctx.font = "18px Inter, sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(
          `HP: ${Math.max(0, Math.round(jogador.vidaAtual))}/${
            jogador.vidaMaxima
          }`,
          hudX + 10,
          hudY + 22
        );

        // Texto da Pontuação
        ctx.fillStyle = "#fff";
        ctx.font = "22px Inter, sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(
          `Pontos: ${jogador.score}`,
          hudX + hudWidth + 20,
          hudY + 24
        );

        // Indicador de Velocidade Atual
        const currentLevelData = LEVEL_DATA[currentLevel];
        const currentEnemySpeed = Math.min(
          MAX_VELOCIDADE_INIMIGO,
          currentLevelData.enemyBaseSpeed +
            jogador.score * SCORE_VELOCIDADE_FATOR
        );
        ctx.fillStyle = "#ffdd00";
        ctx.font = "16px Inter, sans-serif";
        ctx.fillText(
          `Velocidade Inimiga: ${currentEnemySpeed.toFixed(1)}`,
          hudX + hudWidth + 20,
          hudY + 45
        );

        // Indicador de Cooldown do Dash
        const dashCooldownPercent = jogador.dashCooldown / DASH_COOLDOWN_TIME;
        const dashBarWidth = 120;
        const dashBarHeight = 15;
        const dashBarX = hudX + hudWidth + 20;
        const dashBarY = hudY + 60;

        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(dashBarX, dashBarY, dashBarWidth, dashBarHeight);

        if (jogador.dashCooldown > 0) {
          ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; // Vermelho durante o cooldown
          ctx.fillRect(
            dashBarX,
            dashBarY,
            dashBarWidth * dashCooldownPercent,
            dashBarHeight
          );
          ctx.fillStyle = "#fff";
          ctx.fillText(
            "DASH RECARREGANDO",
            dashBarX + dashBarWidth + 10,
            dashBarY + 12
          );
        } else {
          ctx.fillStyle = "#00ffff"; // Ciano quando pronto
          ctx.fillRect(dashBarX, dashBarY, dashBarWidth, dashBarHeight);
          ctx.fillStyle = "#000";
          ctx.fillText(
            "DASH PRONTO (Q)",
            dashBarX + dashBarWidth + 10,
            dashBarY + 12
          );
        }
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(dashBarX, dashBarY, dashBarWidth, dashBarHeight);

        ctx.restore();
      }

      // --- 6. FUNÇÃO DE ATUALIZAÇÃO (UPDATE) ---
      function update() {
        // --- 1. Gerenciamento de Timers de Ação do Jogador ---

        // Cooldown do Dash
        if (jogador.dashCooldown > 0) {
          jogador.dashCooldown--;
        }

        // Timer do Dash
        if (jogador.isDashing) {
          jogador.dashTimer++;
          if (jogador.dashTimer >= DASH_DURATION) {
            jogador.isDashing = false;
            jogador.dashTimer = 0;
            // Ao fim do Dash, zera a velocidade X, mas mantém a Y
            velX = 0;
          }
        }

        // Outros Timers
        if (jogador.isAttacking) {
          jogador.attackTimer++;
          if (jogador.attackTimer >= PLAYER_ATTACK_DURATION) {
            jogador.isAttacking = false;
            jogador.attackTimer = 0;
          }
        }

        if (jogador.isDefending) {
          jogador.defendTimer++;
          if (!teclas["s"] || jogador.defendTimer >= PLAYER_DEFEND_DURATION) {
            jogador.isDefending = false;
            jogador.defendTimer = 0;
          } else if (
            teclas["s"] &&
            jogador.defendTimer >= PLAYER_DEFEND_DURATION
          ) {
            jogador.defendTimer = PLAYER_DEFEND_DURATION - 1;
          }
        }

        // 2. Controles do Jogador

        // Ações que interrompem outras ações
        const isActionBlocked =
          jogador.isAttacking || jogador.isDefending || jogador.isDashing;

        if (jogador.isDashing) {
          // Durante o Dash, apenas movimento forçado
          velY = 0; // Trava a gravidade momentaneamente
          velX = jogador.direcao * DASH_VELOCITY;
        } else if (isActionBlocked) {
          velX = 0; // Trava o movimento
        } else {
          // Movimento Horizontal (A/D)
          if (teclas["d"]) {
            velX = VELOCIDADE_HORIZONTAL;
            jogador.direcao = 1;
          } else if (teclas["a"]) {
            velX = -VELOCIDADE_HORIZONTAL;
            jogador.direcao = -1;
          } else {
            velX = 0;
          }

          // Pulo (W)
          if (teclas["w"] && jogador.noChao) {
            velY = -FORCA_PULO;
            jogador.noChao = false;
          }

          // Dash (Q) - Só pode dar Dash se o cooldown for 0
          if (teclas["q"] && jogador.dashCooldown === 0) {
            jogador.isDashing = true;
            jogador.dashTimer = 0;
            jogador.dashCooldown = DASH_COOLDOWN_TIME;
            // Dash usa a direção atual, então o jogador deve estar se movendo ou ter uma direção definida
            if (velX === 0) {
              velX = jogador.direcao * DASH_VELOCITY;
            }
            jogador.isAttacking = false;
            jogador.isDefending = false;
            jogador.noChao = false; // Permite Dash no ar
          }

          // Defesa (S)
          if (teclas["s"] && jogador.noChao) {
            jogador.isDefending = true;
            if (jogador.defendTimer === 0) jogador.defendTimer = 1;
          }

          // Ataque Normal (Espaço)
          if (teclas[" "]) {
            jogador.isAttacking = true;
            jogador.attackTimer = 0;
            jogador.isDefending = false;
          }
        }

        // 3. Aplica Gravidade e Movimento
        if (!jogador.isDashing) {
          velY += GRAVIDADE;
        }

        jogador.posX += velX;
        jogador.posY += velY;

        // 4. Colisão Vertical com o Chão
        const LIMITE_CHAO = CHAO_Y_COLISAO - jogador.tamanho;
        if (jogador.posY >= LIMITE_CHAO) {
          if (!jogador.noChao) {
            animacaoFrame = 0;
          }
          jogador.posY = LIMITE_CHAO;
          velY = 0;
          jogador.noChao = true;
        }

        // 5. Limite do cenário e Câmera

        // Lógica da Câmera
        if (jogador.posX > cameraOffset + CAMERA_LIMITE_DIR && velX > 0) {
          cameraOffset = jogador.posX - CAMERA_LIMITE_DIR;
        }
        if (jogador.posX < cameraOffset + CAMERA_LIMITE_ESQ && velX < 0) {
          cameraOffset = jogador.posX - CAMERA_LIMITE_ESQ;
        }

        cameraOffset = Math.max(0, cameraOffset);
        jogador.posX = Math.max(0, jogador.posX);

        // NOVO: 5.1 Lógica da Porta e Transição de Nível
        const currentLevelData = LEVEL_DATA[currentLevel];

        if (currentLevelData.scoreRequirement !== Infinity) {
          // Lógica de Spawn da Porta (apenas para níveis com requisito de pontuação)
          if (
            levelDoor === null &&
            jogador.score >= currentLevelData.scoreRequirement
          ) {
            // Spawn da porta ligeiramente à direita da câmera
            const spawnX = cameraOffset + GAME_WIDTH;
            levelDoor = new Door(spawnX, DOOR_Y, DOOR_SIZE);
          }

          if (levelDoor) {
            // Mantém a porta no campo de visão (ou um pouco à frente)
            levelDoor.posX = Math.max(levelDoor.posX, cameraOffset + 100);

            // Abre a porta se a pontuação for alcançada
            levelDoor.isClosed =
              jogador.score < currentLevelData.scoreRequirement;

            if (!levelDoor.isClosed && levelDoor.checkCollision(jogador)) {
              const nextLevel = currentLevel + 1;
              if (LEVEL_DATA[nextLevel]) {
                goToNextLevel(nextLevel);
                return; // Pula o resto do update, o jogo será reiniciado no próximo nível
              }
            }
          }
        }

        // --- 6. Lógica de Health Pickups (Corrigida) ---
        healthSpawnTimer++;
        if (healthSpawnTimer >= HEALTH_SPAWN_INTERVAL) {
          const spawnX = cameraOffset + GAME_WIDTH;
          const hp = new HealthPickup(
            spawnX,
            HEALTH_PICKUP_Y,
            HEALTH_PICKUP_SIZE
          );
          healthPickups.push(hp);
          healthSpawnTimer = 0;
        }

        for (let i = healthPickups.length - 1; i >= 0; i--) {
          const hp = healthPickups[i];
          hp.update();

          // Colisão Jogador vs HP Pickup (apenas se não estiver coletando)
          if (
            !hp.isPickingUp &&
            jogador.posX < hp.posX + hp.tamanho &&
            jogador.posX + jogador.tamanho > hp.posX &&
            jogador.posY < hp.posY + hp.tamanho &&
            jogador.posY + jogador.tamanho > hp.posY
          ) {
            const healAmount = jogador.vidaMaxima * 0.5; // MUDANÇA: A cura agora é de 50%
            jogador.vidaAtual = Math.min(
              jogador.vidaMaxima,
              jogador.vidaAtual + healAmount
            );
            hp.isPickingUp = true; // CORREÇÃO: Removido o typo 'ing'
            hp.pickupFrame = 0;
          }

          if (hp.isConsumed) {
            healthPickups.splice(i, 1);
          }
        }

        // --- 7. Lógica de Spawn e Dificuldade de Inimigos ---
        const currentEnemySpeed = Math.min(
          MAX_VELOCIDADE_INIMIGO,
          currentLevelData.enemyBaseSpeed +
            jogador.score * SCORE_VELOCIDADE_FATOR
        );
        const currentSpawnIntervalo = Math.max(
          MIN_SPAWN_INTERVALO,
          MAX_SPAWN_INTERVALO - jogador.score * SCORE_SPAWN_FATOR
        );

        spawnTimer++;
        if (spawnTimer >= currentSpawnIntervalo) {
          const spawnX = cameraOffset + GAME_WIDTH;
          // PASSANDO DADOS DO NÍVEL PARA O INIMIGO
          const inimigo = new Inimigo(
            spawnX,
            LIMITE_CHAO_JOGADOR,
            TAMANHO_JOGADOR,
            currentLevelData
          );
          inimigos.push(inimigo);
          spawnTimer = 0;
        }

        // --- 8. Lógica de Combate ---

        // Dano do Jogador (Aplicado a Inimigos)
        const playerDamageFrame = Math.floor(PLAYER_ATTACK_DURATION * 0.5);
        const isPlayerHitting =
          jogador.isAttacking && jogador.attackTimer === playerDamageFrame;

        if (isPlayerHitting) {
          const PLAYER_ATTACK_RANGE = jogador.tamanho * 1.5;
          let damage = 20;

          for (let i = inimigos.length - 1; i >= 0; i--) {
            const inimigo = inimigos[i];
            const distanceX = Math.abs(jogador.posX - inimigo.posX);
            if (distanceX < PLAYER_ATTACK_RANGE) {
              inimigo.vidaAtual -= damage;
              if (inimigo.vidaAtual <= 0) {
                inimigo.isDead = true;
                jogador.score += 100 * currentLevel; // Maior pontuação por inimigos de nível superior
              }
            }
          }
        }

        // Atualiza e filtra inimigos
        for (let i = inimigos.length - 1; i >= 0; i--) {
          const inimigo = inimigos[i];
          // Atualiza a velocidade do inimigo com a dificuldade crescente
          inimigo.velocidade = currentEnemySpeed;
          inimigo.update(jogador);

          const distanceX = Math.abs(jogador.posX - inimigo.posX);
          const ENEMY_ATTACK_RANGE = 20;

          // Checa se deve iniciar ataque
          if (
            distanceX < ENEMY_ATTACK_RANGE &&
            inimigo.noChao &&
            !inimigo.isAttacking
          ) {
            inimigo.isAttacking = true;
            inimigo.attackTimer = 0;
          }

          // Dano do Inimigo ao Jogador (Melee)
          const damageFrame = Math.floor(inimigo.attackDuration * 0.5);
          const isEnemyHitting =
            inimigo.isAttacking && inimigo.attackTimer === damageFrame;

          if (isEnemyHitting) {
            // Checa colisão
            if (
              jogador.posX < inimigo.posX + inimigo.tamanho &&
              jogador.posX + jogador.tamanho > inimigo.posX &&
              jogador.posY < inimigo.posY + inimigo.tamanho &&
              jogador.posY + jogador.tamanho > inimigo.posY
            ) {
              let dano = 5 * currentLevel; // Dano maior no nível 2
              // O jogador está invulnerável durante o Dash (isDashing) ou pode defender
              if (jogador.isDefending || jogador.isDashing)
                dano = 1 * currentLevel;

              jogador.vidaAtual -= dano;
              if (jogador.vidaAtual < 0) jogador.vidaAtual = 0;
            }
          }

          // Remove inimigos
          if (inimigo.posX + inimigo.tamanho < cameraOffset || inimigo.isDead) {
            inimigos.splice(i, 1);
          }
        }

        // --- 9. Check Game Over ---
        if (jogador.vidaAtual <= 0) {
          currentGameState = GAME_STATE.GAME_OVER;
        }
      }

      // --- 7. O Loop Principal do Jogo ---
      function gameLoop() {
        if (currentGameState === GAME_STATE.PLAYING) {
          update();
          draw();
          animationFrameId = requestAnimationFrame(gameLoop);
        } else if (currentGameState === GAME_STATE.GAME_OVER) {
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
          if (!isGameOver) {
            drawGameOverScreen(); // Inicia o loop da tela de game over
          }
        }
        // O estado PAUSED é tratado fora do loop
      }

      // --- Função para Iniciar o Jogo ---
      function startGame() {
        showScreen(gameScreen);
        // Redimensionar o overlay de pausa para corresponder ao canvas real
        const canvasRect = canvas.getBoundingClientRect();
        pauseContainer.style.width = `${canvasRect.width}px`;
        pauseContainer.style.height = `${canvasRect.height}px`;

        updateLevelDisplay(); // Atualiza a HUD do nível

        if (currentGameState === GAME_STATE.PLAYING && !animationFrameId) {
          gameLoop();
        } else if (
          currentGameState === GAME_STATE.PLAYING &&
          animationFrameId
        ) {
          // Se já estiver rodando, apenas garante que o menu de pausa está oculto
          updatePauseMenuVisibility();
        }
      }

      // --- Inicialização do Menu e Listeners ---

      function setupMenu() {
        // --- Menu Principal ---
        mainMenuOptions.innerHTML = `
              <li><button class="menu-button" data-action="new-game">NOVO JOGO</button></li>
              <li><button class="menu-button" data-action="options">OPÇÕES</button></li>
              <li><button class="menu-button" data-action="quit">SAIR</button></li>
          `;

        // --- Menu de Pausa ---
        pauseMenuOptions.innerHTML = `
              <li><button class="menu-button" data-action="continue">CONTINUAR</button></li>
              <li><button class="menu-button" data-action="new-game">NOVO JOGO</button></li>
              <li><button class="menu-button" data-action="quit-to-menu">SAIR PARA O MENU</button></li>
          `;

        // --- Listener de Ações ---
        document.addEventListener("click", (e) => {
          if (e.target.classList.contains("menu-button")) {
            const action = e.target.getAttribute("data-action");
            if (action === "new-game") {
              restartGame();
            } else if (action === "continue") {
              unpauseGame();
            } else if (action === "quit-to-menu") {
              backToMenu();
            } else if (action === "quit") {
              console.log('Ação "Sair" não suportada neste ambiente.');
            } else if (action === "options") {
              console.log("Opções: Nenhuma configurada ainda.");
            }
          }
        });
      }

      window.onload = () => {
        setupMenu();
        showScreen(menuScreen);
        focusFirstMenuButton(mainMenuOptions);

        // Ajusta o tamanho do overlay de pausa ao carregar
        const canvasRect = canvas.getBoundingClientRect();
        pauseContainer.style.width = `${canvasRect.width}px`;
        pauseContainer.style.height = `${canvasRect.height}px`;
      };
    </script>
  </body>
</html>
